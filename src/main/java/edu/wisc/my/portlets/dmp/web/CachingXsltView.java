/**
 * Copyright 2007 The JA-SIG Collaborative.  All rights reserved.
 * See license distributed with this file and
 * available online at http://www.uportal.org/license.html
 */
package edu.wisc.my.portlets.dmp.web;

import java.io.BufferedOutputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamResult;

import org.springframework.web.servlet.view.xslt.AbstractXsltView;

/**
 * Extends AbstractXsltView to perform caching. The results of XSLT transformations are cached in the
 * configured Map using the key object specified in the model by the {@link #setContentCacheKey(String)}
 * property.
 * 
 * @author Eric Dalquist
 * @version $Revision: 1.1 $
 */
public class CachingXsltView extends AbstractXsltView {
    private Map<Serializable, String> xsltResultCache;
    private String contentCacheKey = "contentCacheKey";
    
    /**
     * @return the xsltResultCache
     */
    public Map<Serializable, String> getXsltResultCache() {
        return xsltResultCache;
    }
    /**
     * @param xsltResultCache the xsltResultCache to set
     */
    public void setXsltResultCache(Map<Serializable, String> xsltResultCache) {
        this.xsltResultCache = xsltResultCache;
    }

    /**
     * @return the contentCacheKey
     */
    public String getContentCacheKey() {
        return contentCacheKey;
    }
    /**
     * @param contentCacheKey the contentCacheKey to set
     */
    public void setContentCacheKey(String contentCacheKey) {
        this.contentCacheKey = contentCacheKey;
    }

    @SuppressWarnings("unchecked")
    @Override
    protected void doTransform(Map model, Source source, HttpServletRequest request, HttpServletResponse response) throws Exception {
        final Map parameters = getParameters(model, request);
        final Serializable cacheKey = this.getCacheKey(model, source, parameters);
        
        String cachedData;
        synchronized (this.xsltResultCache) {
            cachedData = this.xsltResultCache.get(cacheKey);
            if (cachedData == null) {
                final StringWriter writer = new StringWriter();
                
                final String encoding = response.getCharacterEncoding();
                this.doTransform(source, parameters, new StreamResult(writer), encoding);
                
                cachedData = writer.getBuffer().toString();
                this.xsltResultCache.put(cacheKey, cachedData);
            }
        }
        
        if (useWriter()) {
            final PrintWriter writer = response.getWriter();
            writer.write(cachedData);
            writer.flush();
        }
        else {
            final OutputStream outputStream = new BufferedOutputStream(response.getOutputStream());
            outputStream.write(cachedData.getBytes());
            outputStream.flush();
        }
    }
    
    /**
     * Generates the serializable cache key to use for content generated by this request
     */
    protected Serializable getCacheKey(Map<?, ?> model, Source source, Map<?, ?> parameters) {
        final Serializable cacheKey = (Serializable) model.get(this.contentCacheKey);
        if (cacheKey == null) {
            throw new IllegalArgumentException("Unable to locate XSLT Cache Key under key='" + this.contentCacheKey + "' in model: " + model);
        }
        
        return cacheKey;
    }
}
